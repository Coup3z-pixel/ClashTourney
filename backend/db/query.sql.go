// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one

INSERT INTO Game (title, player1Id, player2Id, tournamentId) 
VALUES ($1, $2, $3, $4) 
RETURNING gameid, title, player1id, player2id, tournamentid
`

type CreateGameParams struct {
	Title        pgtype.Text
	Player1id    pgtype.UUID
	Player2id    pgtype.UUID
	Tournamentid pgtype.UUID
}

// Game Queries
// Based on all flows: "Set up tournament" (creates games), "Enter Tournament" (returns a game), "Update Game" (updates game state).
// Creates a new game for a tournament.
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame,
		arg.Title,
		arg.Player1id,
		arg.Player2id,
		arg.Tournamentid,
	)
	var i Game
	err := row.Scan(
		&i.Gameid,
		&i.Title,
		&i.Player1id,
		&i.Player2id,
		&i.Tournamentid,
	)
	return i, err
}

const createPlayer = `-- name: CreatePlayer :one

INSERT INTO Player (userName, userTag, password_hash) 
VALUES ($1, $2, crypt($3, gen_salt('bf', 8)))
RETURNING userid, username, usertag, passwordhash
`

type CreatePlayerParams struct {
	Username string
	Usertag  string
	Crypt    string
}

// SQL Queries for ClashTourneyDB Player Queries
// Based on "Enter Tournament" and "Set up tournament" flows which involve players.
// Inserts a new player into the Player table.
func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer, arg.Username, arg.Usertag, arg.Crypt)
	var i Player
	err := row.Scan(
		&i.Userid,
		&i.Username,
		&i.Usertag,
		&i.Passwordhash,
	)
	return i, err
}

const createTournament = `-- name: CreateTournament :one

INSERT INTO Tournament (entryFee) 
VALUES ($1) 
RETURNING tournamentid, entryfee
`

// Tournament Queries
// Based on "Set up tournament" flow.
// Creates a new tournament.
func (q *Queries) CreateTournament(ctx context.Context, entryfee pgtype.Numeric) (Tournament, error) {
	row := q.db.QueryRow(ctx, createTournament, entryfee)
	var i Tournament
	err := row.Scan(&i.Tournamentid, &i.Entryfee)
	return i, err
}

const getGame = `-- name: GetGame :one
SELECT gameid, title, player1id, player2id, tournamentid FROM Game 
WHERE gameId = $1
`

// Retrieves a game by its ID.
func (q *Queries) GetGame(ctx context.Context, gameid pgtype.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGame, gameid)
	var i Game
	err := row.Scan(
		&i.Gameid,
		&i.Title,
		&i.Player1id,
		&i.Player2id,
		&i.Tournamentid,
	)
	return i, err
}

const getGamesByTournament = `-- name: GetGamesByTournament :many
SELECT gameid, title, player1id, player2id, tournamentid FROM Game 
WHERE tournamentId = $1
`

// Retrieves all games associated with a specific tournament.
func (q *Queries) GetGamesByTournament(ctx context.Context, tournamentid pgtype.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getGamesByTournament, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.Gameid,
			&i.Title,
			&i.Player1id,
			&i.Player2id,
			&i.Tournamentid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerByUserTag = `-- name: GetPlayerByUserTag :one
SELECT userid, username, usertag, passwordhash FROM Player 
WHERE userTag = $1
`

// Retrieves a player by their unique userTag. Used to check if a player exists.
func (q *Queries) GetPlayerByUserTag(ctx context.Context, usertag string) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByUserTag, usertag)
	var i Player
	err := row.Scan(
		&i.Userid,
		&i.Username,
		&i.Usertag,
		&i.Passwordhash,
	)
	return i, err
}

const getTournament = `-- name: GetTournament :one
SELECT tournamentid, entryfee FROM Tournament 
WHERE tournamentId = $1
`

// Retrieves a tournament by its ID.
func (q *Queries) GetTournament(ctx context.Context, tournamentid pgtype.UUID) (Tournament, error) {
	row := q.db.QueryRow(ctx, getTournament, tournamentid)
	var i Tournament
	err := row.Scan(&i.Tournamentid, &i.Entryfee)
	return i, err
}

const listPlayers = `-- name: ListPlayers :many
SELECT userid, username, usertag, passwordhash FROM Player
`

// Lists all players. Used in "Set up tournament" to get all participants.
func (q *Queries) ListPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.Userid,
			&i.Username,
			&i.Usertag,
			&i.Passwordhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGame = `-- name: UpdateGame :one
UPDATE Game 
SET title = $2 
WHERE gameId = $1 
RETURNING gameid, title, player1id, player2id, tournamentid
`

type UpdateGameParams struct {
	Gameid pgtype.UUID
	Title  pgtype.Text
}

// Updates a game's title, potentially to reflect the game's outcome.
func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, updateGame, arg.Gameid, arg.Title)
	var i Game
	err := row.Scan(
		&i.Gameid,
		&i.Title,
		&i.Player1id,
		&i.Player2id,
		&i.Tournamentid,
	)
	return i, err
}

const verifyPlayer = `-- name: VerifyPlayer :one
SELECT (password_hash = crypt($2, password_hash)) AS password_match
FROM Player
WHERE userName = $1
`

type VerifyPlayerParams struct {
	Username string
	Crypt    string
}

// Checks for if username and pasword are right
func (q *Queries) VerifyPlayer(ctx context.Context, arg VerifyPlayerParams) (bool, error) {
	row := q.db.QueryRow(ctx, verifyPlayer, arg.Username, arg.Crypt)
	var password_match bool
	err := row.Scan(&password_match)
	return password_match, err
}
